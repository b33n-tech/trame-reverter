<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Trame Académique Drag & Drop</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 40px;
    background: #f5f5f5;
  }
  h1 {
    text-align: center;
  }
  #inputSection {
    margin-bottom: 20px;
  }
  textarea {
    width: 100%;
    height: 150px;
    padding: 10px;
    font-size: 16px;
  }
  button {
    margin: 10px 5px 10px 0;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
  }
  #output {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .box {
    background: #fff;
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    cursor: grab;
    user-select: none;
  }
  .box.dragging {
    opacity: 0.5;
  }
</style>
</head>
<body>

<h1>Trame Académique Drag & Drop</h1>

<div id="inputSection">
  <p>Écris tes points dans l'ordre "à rebours" :</p>
  <textarea id="input"></textarea><br>
  <button onclick="invertOrder()">Réorganiser à l'endroit</button>
  <button onclick="clearAll()">Tout effacer</button>
</div>

<h2>Trame organisée :</h2>
<div id="output"></div>

<script>
const output = document.getElementById('output');

function invertOrder() {
  const input = document.getElementById('input').value;
  const lines = input.split('\n').filter(line => line.trim() !== '');
  const reversed = lines.reverse();
  renderBoxes(reversed);
  document.getElementById('input').value = '';
}

function clearAll() {
  output.innerHTML = '';
}

// Fonction pour créer les boxes
function renderBoxes(lines) {
  output.innerHTML = '';
  lines.forEach((line) => {
    const div = document.createElement('div');
    div.className = 'box';
    div.textContent = line;
    makeDraggable(div);
    output.appendChild(div);
  });
}

// Drag & Drop
let dragged = null;

function makeDraggable(element) {
  element.draggable = true;

  element.addEventListener('dragstart', (e) => {
    dragged = element;
    element.classList.add('dragging');
  });

  element.addEventListener('dragend', (e) => {
    dragged = null;
    element.classList.remove('dragging');
  });

  element.addEventListener('dragover', (e) => {
    e.preventDefault();
    const bounding = element.getBoundingClientRect();
    const offset = e.clientY - bounding.top;
    if(offset > bounding.height / 2) {
      element.style['border-bottom'] = '2px solid #000';
      element.style['border-top'] = '';
    } else {
      element.style['border-top'] = '2px solid #000';
      element.style['border-bottom'] = '';
    }
  });

  element.addEventListener('dragleave', (e) => {
    element.style['border-top'] = '';
    element.style['border-bottom'] = '';
  });

  element.addEventListener('drop', (e) => {
    e.preventDefault();
    if(dragged && dragged !== element){
      const bounding = element.getBoundingClientRect();
      const offset = e.clientY - bounding.top;
      if(offset > bounding.height / 2){
        element.style['border-bottom'] = '';
        element.parentNode.insertBefore(dragged, element.nextSibling);
      } else {
        element.style['border-top'] = '';
        element.parentNode.insertBefore(dragged, element);
      }
    }
  });
}
</script>

</body>
</html>
